
<!-- saved from url=(0074)https://googledrive.com/host/0B7cAS_dEul22MlEtRFhabkc0a2c/personality.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Title" content="Code and Personality">
<meta name="Keywords" content="">

<title>Code and Personality</title>
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:"Times New Roman";
	panose-1:0 2 2 6 3 5 4 5 2 3;}
@font-face
	{font-family:Geneva;
	panose-1:0 2 11 5 3 3 4 4 4 2;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:Times;}
h1
	{margin-top:12.6pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	font-size:18.0pt;
	font-family:Times;}
h2
	{margin-top:12.6pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	font-size:14.0pt;
	font-family:Times;}
h3
	{margin-top:.1in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:Times;}
p.MsoFootnoteText, li.MsoFootnoteText, div.MsoFootnoteText
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:Times;}
span.MsoFootnoteReference
	{vertical-align:super;}
span.MsoEndnoteReference
	{vertical-align:super;}
p.SpecialRequest, li.SpecialRequest, div.SpecialRequest
	{margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	font-size:14.0pt;
	font-family:Helvetica;
	color:red;
	font-weight:bold;}
p.CodeComment, li.CodeComment, div.CodeComment
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.1in;
	margin-bottom:.0001pt;
	font-size:10.0pt;
	font-family:Courier;
	font-style:italic;}
p.Quote, li.Quote, div.Quote
	{margin-top:.1in;
	margin-right:.5in;
	margin-bottom:.1in;
	margin-left:.5in;
	text-indent:11.95pt;
	font-size:12.0pt;
	font-family:Times;}
p.list, li.list, div.list
	{margin-top:.7pt;
	margin-right:0in;
	margin-bottom:.7pt;
	margin-left:23.75pt;
	text-indent:-.2in;
	tab-stops:23.75pt 38.15pt;
	font-size:12.0pt;
	font-family:Times;}
p.Note, li.Note, div.Note
	{margin-top:0in;
	margin-right:24.0pt;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	text-indent:24.0pt;
	font-size:10.0pt;
	font-family:Times;
	font-style:italic;}
p.TableHeader, li.TableHeader, div.TableHeader
	{margin-top:.1in;
	margin-right:.5in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	font-size:10.0pt;
	font-family:Times;
	font-weight:bold;}
p.TableRow, li.TableRow, div.TableRow
	{margin-top:0in;
	margin-right:.5in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	font-size:10.0pt;
	font-family:Times;}
p.Bibliography, li.Bibliography, div.Bibliography
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:23.75pt;
	margin-bottom:.0001pt;
	text-indent:-23.75pt;
	tab-stops:23.75pt;
	font-size:12.0pt;
	font-family:Times;}
p.Code, li.Code, div.Code
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.1in;
	margin-bottom:.0001pt;
	font-size:10.0pt;
	font-family:Courier;}
p.FigureDescription, li.FigureDescription, div.FigureDescription
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:.1in;
	margin-left:0in;
	text-align:center;
	font-size:12.0pt;
	font-family:Times;
	font-style:italic;}
p.Figure, li.Figure, div.Figure
	{margin-top:.1in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	text-align:center;
	font-size:12.0pt;
	font-family:Times;
	color:red;}
p.FigureLabel, li.FigureLabel, div.FigureLabel
	{margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	font-size:12.0pt;
	font-family:Times;
	font-weight:bold;
	font-style:italic;}
p.Author, li.Author, div.Author
	{margin-top:.05in;
	margin-right:0in;
	margin-bottom:12.6pt;
	margin-left:0in;
	text-align:center;
	font-size:14.0pt;
	font-family:Times;}
p.Abstract, li.Abstract, div.Abstract
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:.1in;
	margin-left:0in;
	text-indent:24.0pt;
	font-size:12.0pt;
	font-family:Times;
	font-style:italic;}
p.SubTitle, li.SubTitle, div.SubTitle
	{margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	font-size:18.0pt;
	font-family:Helvetica;}
p.title, li.title, div.title
	{margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	font-size:24.0pt;
	font-family:Helvetica;}
p.Bodytext, li.Bodytext, div.Bodytext
	{margin:0in;
	margin-bottom:.0001pt;
	text-indent:24.0pt;
	font-size:12.0pt;
	font-family:Times;}
p.plaintext, li.plaintext, div.plaintext
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:10.0pt;
	font-family:Times;}
p.documentmap, li.documentmap, div.documentmap
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:Geneva;}
p.blocktext, li.blocktext, div.blocktext
	{margin-top:0in;
	margin-right:1.0in;
	margin-bottom:6.0pt;
	margin-left:1.0in;
	font-size:12.0pt;
	font-family:Times;}
 /* Page Definitions */
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;}
div.Section1
	{page:Section1;}
-->
</style>
<style type="text/css"></style></head>

<body bgcolor="white" lang="EN-US" style="tab-interval:.5in">

<div class="Section1">

<p class="title">Code and Personality</p>

<p class="SubTitle" align="left" style="text-align:left">How to tell your
personality type from your code.</p>

<p class="Author">&nbsp;</p>

<p class="Author">Kevin Marks &amp; Maf Vosburgh</p>

<p class="Author"><span style="font-size:10.0pt">kmarks@mac.com     
maf@goat.demon.co.uk</span></p>

<p class="Abstract">&nbsp;</p>

<p class="Abstract" style="text-indent:0in">People with different personalities
write the same code different ways. Unfortunately, not all these ways actually
work, but people can learn to change...</p>

<h2>Introduction </h2>

<p class="Bodytext" style="text-indent:0in">There are various types of
programmers around. We’ve certainly worked with a wide selection. Over the
years, we've come to realize that programmers can be divided into various
"personality types". You don't stay the same personality-type your whole life though
— as you develop and learn, your approach to programming changes and that
change is visible in your code. We're going to look at various functions and
how programmers with different personalities would write them.</p>

<p class="Bodytext" style="text-indent:0in">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">MacHack attendees have normally been
around the block a few times. That means they have learnt various things, like
when you're going around the block, it helps to watch where you're going, and
be driving a tank.  We know that a function has important responsibilities. It
needs to check every error code, keep track of every byte it allocates, and
that function needs to know how to cope with anything that happens, cleaning up
perfectly after itself and returning an error code which explains what went
wrong. But in order to write code like this you have to have made mistakes and
learned from them. We know we have.</p>

<h2>Optimistic</h2>

<p class="Bodytext" style="text-indent:0in">Everyone starts out by being
Optimistic.  Optimistic programmers assume that system calls will always
succeed, there is always enough memory and disc space, and there really is a
Santa Claus.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">You can spot Optimistic programmers
by their novel approach to error checking. For instance, here's an Optimistic
function to return a memory buffer filled with 0xFF.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">char * GetTheBuffer(unsigned long&nbsp; bufferSize)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *p
= NewPtr(bufferSize);<br>
&nbsp;&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp;&nbsp; x;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; for (x = 0  ; x &lt; bufferSize ; x++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p[x] = 0xFF;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; return p;<br>
}<br>
<br>
</p>

<p class="FigureLabel">Listing 1: Optimists get to see a lot of Macsbug.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">Guess what happens if NewPtr fails?
Yes, it returns NULL and you then overwrite say the low ten megs of memory,
depending on the value of bufferSize. Cool.</p>

<p class="Bodytext" style="text-indent:0in">&nbsp;</p>

<h2>Petulant</h2>

<p class="Bodytext" style="text-indent:0in">You can't stay an Optimist once
you've watched your code crash horribly a few dozen times. For many, the next
step is to become Petulant.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">char * GetTheBuffer(unsigned long&nbsp; bufferSize)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *p
= NewPtr(bufferSize);<br>
&nbsp;&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp;&nbsp; x;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (p == NULL)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DebugStr("\p
Error - cannot allocate buffer!");<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; for (x = 0  ; x &lt; bufferSize ; x++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p[x] = 0xFF;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; return p;<br>
}</p>

<p class="Figure"><span style="color:black"><b><i>Listing 2. Petulant programmer
going critical.</i></b></span>.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext"> "Important Notes (Heading 2" \l 1 </p>

<p class="Bodytext" style="text-indent:0in">As you can see, Petulant programmers
detect that something has gone wrong, complain about it in a primitive way, and
then they crash your machine anyway. Not very useful. Any error you detect, you
should cope with.</p>

<p class="Bodytext">&nbsp;</p>

<h2>Stoic</h2>

<p class="Bodytext" style="text-indent:0in">The next stage in evolution is to
handle any errors that occur, but keep quiet about them. This is the sort of 
"stiff upper lip" approach that built the British Empire (and made sure it
didn't last). As Pink Floyd said on Dark Side of the Moon, "Hanging on in quiet
desperation is the English way". Let's call this personality Stoic.</p>

<p class="Bodytext">&nbsp;</p>

<span style="font-size:10.0pt;font-family:Courier"><br clear="ALL" style="page-break-before:always">
</span>

<p class="Code">char * GetTheBuffer(unsigned long&nbsp; bufferSize)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *p
= NewPtr(bufferSize);<br>
&nbsp;&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp;&nbsp; x;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; if(p != NULL)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (x = 0  ; x
&lt; bufferSize ; x++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p[x]
= 0xFF;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; return p;<br>
}</p>

<p class="Bodytext">&nbsp;</p>

<p class="FigureLabel">Listing 3. Stoics suffer in silence.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">This approach is pretty good - if the
allocation fails the routine does not trash memory, and it returns NULL, which
is a pretty standard thing to do when an allocation fails. The trouble with
this style, is that you are not telling the caller why you failed. Some
functions can fail for any number of different reasons, and it helps to pass
that information on. Furthermore, you are assuming that the caller realizes
that your function will sometimes return NULL. If the person calling your
function is an Optimist, you're back at square one, as they will happily take
that NULL buffer and start using it.</p>

<p class="Bodytext" style="text-indent:0in">&nbsp;</p>

<h2>Realists</h2>

<p class="Bodytext" style="text-indent:0in">Of course grown-up programmers (the
sort who come to MacHack) are Realists. They know that problems are inevitable,
and when things go wrong, you need to tell the caller about that. Also, if your
function returns OSErr, just by looking at the prototype they can see that
errors may happen, and know that they need to plan for that.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code"><br>
OSErr GetTheBuffer(unsigned long&nbsp;&nbsp; bufferSize, <br>
char **returned)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; OSErr &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = noErr;<br>
&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp; *p =  NewPtr(bufferSize);<br>
&nbsp;&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp;&nbsp; x;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (p == NULL)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result =
memFullErr;<br>
&nbsp;&nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (x = 0  ; x
&lt; bufferSize ; x++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p[x]
= 0xFF;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; *returned = p;<br>
&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
}</p>

<p class="FigureLabel">Listing 4. Realists do the right thing.</p>

<p class="FigureDescription">&nbsp;</p>

<p class="Bodytext">You could just stop here - at this point the code is doing
the right thing, or telling the caller why it couldn't. It isn't leaking or
trashing memory. </p>

<p class="Bodytext">&nbsp;</p>

<h2>Considerate</h2>

<p class="Bodytext">However you may want to help others see the errors of their
ways (in the debug build at least), and become a Considerate programmer.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">OSErr GetTheBuffer(unsigned long&nbsp;&nbsp; bufferSize, char
**returned)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; OSErr &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = noErr;<br>
&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp; *p =  NULL;<br>
&nbsp;&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp;&nbsp;&nbsp; x;<br>
&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; if (bufferSize == 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DebugText("GetTheBuffer:
a zero-size buffer is no use");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = paramErr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p =
NewPtr(bufferSize);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (p == NULL)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DebugText("GetTheBuffer:
couldn't get the buffer");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result
= memFullErr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for
(x = 0  ; x &lt; bufferSize ; x++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p[x]
= 0xFF;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp; *returned = p;<br>
&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
}</p>

<p class="Bodytext">&nbsp;</p>

<p class="FigureLabel">Listing 5. Considerate programmers keep you informed.</p>

<p class="Bodytext" style="text-indent:0in">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">DebugText is defined something like
this:</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">#ifdef DEBUG<br>
#define DebugText(x) debugstr(x)<br>
#else<br>
#define DebugText(x) <br>
#endif</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">DEBUG is the preprocessor global you
use to distinguish between the debugging and final builds of your app. You
could define DebugText to log to a file, or put up an alert - the point is to
have a way of signaling to other programmers (or yourself) that something odd
is going on in your routine, but to protect the end user from it by coping
nicely.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in;tab-stops:35.45pt">The programmer here
not only returns sensible error values, but in the debug build he also stops
the program when passed a buffer that is too big - handy for debugging the
calling code too. However, by not using an assert, he doesn't inflict this on
the end-user. That would be not just Petulant, but Sociopathic as well.</p>

<h2>Extravagant</h2>

<p class="Bodytext" style="text-indent:0in">A common personality type that you
come across is the Extravagant programmer.  Extravagant programmers back out
when an error happens, but they don't bother disposing of the stuff they
allocated along the way. That causes programs that work fine until an error
occurs, causing a leak, which takes up memory and causes another error, and so
on until the program eventually fails catastrophically.</p>

<p class="Bodytext">The trend to use C++ exceptions contributes to this problem,
since they make it so easy to just jump up several levels of execution, happily
leaking all sorts of things</p>

<p class="Bodytext" style="text-indent:0in">ResizeGrayScalePicHandle is a C
example of a function that needs to allocate a bunch of things and do some real
work.</p>

<p class="Bodytext" style="text-indent:0in">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">Some little things we need to define
before the example:</p>

<p class="Bodytext" style="text-indent:0in">&nbsp;</p>

<p class="Code">const short k8BitGrayScaleID = 32 + 8;<br>
<br>
void QDNormal(void)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; ForeColor(blackColor);<br>
&nbsp;&nbsp;&nbsp;&nbsp; BackColor(whiteColor);<br>
&nbsp;&nbsp;&nbsp;&nbsp; PenNormal();<br>
}</p>

<p class="Code">&nbsp;</p>

<p class="Code">// make the left and top coords 0</p>

<p class="Code">&nbsp;</p>

<p class="Code">void ZeroRect(Rect&nbsp;&nbsp;&nbsp;&nbsp; *r)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; OffsetRect(r, -r-&gt;left, -r-&gt;top);<br>
}</p>

<p class="Code">&nbsp;</p>

<p class="Code">&nbsp;</p>

<p class="Code">// zero the position and scale</p>

<p class="Code">&nbsp;</p>

<p class="Code">void ScaleRect(Rect&nbsp;&nbsp;&nbsp; *r, double scale)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; ZeroRect(r);<br>
&nbsp;&nbsp;&nbsp;&nbsp; r-&gt;right = ((double)r-&gt;right) * scale; <br>
&nbsp;&nbsp;&nbsp;&nbsp; r-&gt;bottom = ((double)r-&gt;bottom) * scale;<br>
}</p>

<p class="Code">&nbsp;</p>

<p class="Code">OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResizeGrayScalePicHandle(PicHandle&nbsp; inPic,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PicHandle
&nbsp; *outPic,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scale)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; Rect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inRect
= inPic [0]-&gt; picFrame<a href="https://googledrive.com/host/0B7cAS_dEul22MlEtRFhabkc0a2c/personality.html#_ftn1" name="_ftnref1" title=""><span class="MsoFootnoteReference">[1]</span></a>;<br>
&nbsp;&nbsp;&nbsp;&nbsp; Rect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outRect
= inRect;<br>
&nbsp;&nbsp;&nbsp;&nbsp; GWorldPtr&nbsp;&nbsp; inWorld, outWorld;<br>
&nbsp;&nbsp;&nbsp;&nbsp; GDHandle&nbsp;&nbsp;&nbsp; saveGD;<br>
&nbsp;&nbsp;&nbsp;&nbsp; CGrafPtr&nbsp;&nbsp;&nbsp; savePort;<br>
&nbsp;&nbsp;&nbsp;&nbsp; CTabHandle&nbsp; grayTab =
GetCTable(k8BitGrayScaleID);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (grayTab == NULL)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return memFullErr;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; ZeroRect(&amp;inRect);<br>
&nbsp;&nbsp;&nbsp;&nbsp; ScaleRect(&amp;outRect, scale);<br>
&nbsp;&nbsp;&nbsp;&nbsp; result = NewGWorld(&amp;inWorld, 8, &amp;inRect,
grayTab, NULL, 0);<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (result != noErr)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; GetGWorld(&amp;savePort, &amp;saveGD);<br>
&nbsp;&nbsp;&nbsp;&nbsp; SetGWorld(inWorld, NULL);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; result = NewGWorld(&amp;outWorld, 8, &amp;outRect,
grayTab, NULL, 0);<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (result != noErr)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; LockPixels(GetGWorldPixMap(inWorld));&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; LockPixels(GetGWorldPixMap(outWorld));<br>
&nbsp;&nbsp;&nbsp;&nbsp; EraseRect(&amp;inRect);<br>
&nbsp;&nbsp;&nbsp;&nbsp; DrawPicture(inPic, &amp;inRect);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; SetGWorld(outWorld, NULL);<br>
&nbsp;&nbsp;&nbsp;&nbsp; CopyBits(&nbsp;&nbsp; (BitMap*)
*inWorld-&gt;portPixMap,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (BitMap*)
*outWorld-&gt;portPixMap,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;inRect,
&amp;outRect, ditherCopy, NULL );<br>
&nbsp;&nbsp;&nbsp;&nbsp; *outPic = OpenPicture(&amp;outRect);<br>
&nbsp;&nbsp;&nbsp;&nbsp; CopyBits(&nbsp;&nbsp; &amp;qd.thePort-&gt;portBits,
&amp;qd.thePort-&gt;portBits,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;outRect,
&amp;outRect,srcCopy, NULL);<br>
&nbsp;&nbsp;&nbsp;&nbsp; ClosePicture();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; DisposeGWorld(inWorld);<br>
&nbsp;&nbsp;&nbsp;&nbsp; DisposeGWorld(outWorld);<br>
&nbsp;&nbsp;&nbsp;&nbsp; DisposeCTable(grayTab);<br>
&nbsp;&nbsp;&nbsp;&nbsp; SetGWorld(savePort, saveGD);<br>
&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
}<br>
<br>
</p>

<p class="FigureLabel">Listing 6. Extravagant programmer wants your heap.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">You can see that there is an attempt
at error handling, but if the program fails it leaves things in a sorry state.
If a failure occurs it can leak a GWorld, a color table, and can also leave the
QuickDraw port set to one of the leaked offscreen GWorlds.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">This kind of real-world function
shows how complicated real error handling can be, but luckily there is a simple
style that can cope with this sort of problem. Just keep all the cleaning up
code at the end of the function, as above, and write it in such a way that it
always safe to execute, and just jump to that block if an error occurs.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResizeGrayScalePicHandle(&nbsp;&nbsp;&nbsp;&nbsp; PicHandle&nbsp;&nbsp; inPic,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PicHandle
&nbsp; *outPic,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
&nbsp;&nbsp;&nbsp;&nbsp; scale)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; Rect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inRect
= inPic [0]-&gt; picFrame;<br>
&nbsp;&nbsp;&nbsp;&nbsp; Rect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outRect
= inRect;<br>
&nbsp;&nbsp;&nbsp;&nbsp; GWorldPtr&nbsp;&nbsp; inWorld = NULL, outWorld = NULL;<br>
&nbsp;&nbsp;&nbsp;&nbsp; GDHandle&nbsp;&nbsp;&nbsp; saveGD;<br>
&nbsp;&nbsp;&nbsp;&nbsp; CGrafPtr&nbsp;&nbsp;&nbsp; savePort;<br>
&nbsp;&nbsp;&nbsp;&nbsp; CTabHandle&nbsp; grayTab =
GetCTable(k8BitGrayScaleID);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; GetGWorld(&amp;savePort, &amp;saveGD);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (grayTab == NULL)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result =
memFullErr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto bail;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; ZeroRect(&amp;inRect);<br>
&nbsp;&nbsp;&nbsp;&nbsp; ScaleRect(&amp;outRect, scale);</p>

<p class="Code"><br>
&nbsp;&nbsp;&nbsp;&nbsp; result = NewGWorld(&amp;inWorld, 8, &amp;inRect,
grayTab, NULL, 0);<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (result != noErr)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto bail;</p>

<p class="Code"><br>
&nbsp;&nbsp;&nbsp;&nbsp; result = NewGWorld(&amp;outWorld, 8, &amp;outRect,
grayTab, NULL, 0);<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (result != noErr)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto bail;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; SetGWorld(inWorld, NULL);<br>
&nbsp;&nbsp;&nbsp;&nbsp; LockPixels(GetGWorldPixMap(inWorld));<br>
&nbsp;&nbsp;&nbsp;&nbsp; LockPixels(GetGWorldPixMap(outWorld));<br>
&nbsp;&nbsp;&nbsp;&nbsp; QDNormal();<br>
&nbsp;&nbsp;&nbsp;&nbsp; EraseRect(&amp;inRect);<br>
&nbsp;&nbsp;&nbsp;&nbsp; DrawPicture(inPic, &amp;inRect);<br>
&nbsp;&nbsp;&nbsp;&nbsp; SetGWorld(outWorld, NULL);<br>
&nbsp;&nbsp;&nbsp;&nbsp; QDNormal();<br>
&nbsp;&nbsp;&nbsp;&nbsp; CopyBits(&nbsp;&nbsp; (BitMap*)
*inWorld-&gt;portPixMap,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (BitMap*)
*outWorld-&gt;portPixMap,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;inRect,
&amp;outRect, ditherCopy, NULL );<br>
&nbsp;&nbsp;&nbsp;&nbsp; DisposeGWorld(inWorld);<br>
&nbsp;&nbsp;&nbsp;&nbsp; inWorld = NULL;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; *outPic = OpenPicture(&amp;outRect);<br>
&nbsp;&nbsp;&nbsp;&nbsp; CopyBits(&nbsp;&nbsp; &amp;qd.thePort-&gt;portBits,
&amp;qd.thePort-&gt;portBits,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;outRect,
&amp;outRect,srcCopy, NULL);<br>
&nbsp;&nbsp;&nbsp;&nbsp; ClosePicture();<br>
<br>
bail:<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (inWorld)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisposeGWorld(inWorld);<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (outWorld)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisposeGWorld(outWorld);<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (grayTab)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisposeCTable(grayTab);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; SetGWorld(savePort, saveGD);<br>
&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
}</p>

<p class="Bodytext">&nbsp;</p>

<p class="FigureLabel">Listing 7. Cleans up properly on error now, but a little
verbose.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">Notice how everything is always
disposed, there is no duplication of cleanup code, and all errors are checked
and returned. Initialising all storage to NULL, means that the cleanup code can
easily see what needs to be disposed. See how when we dispose inWorld in the
middle of the function, we set it to NULL, so the cleanup code knows not to
dispose it again.</p>

<p class="Bodytext" style="text-indent:0in">Of course some people say that <span style="font-size:10.0pt;font-family:Courier">goto</span> is evil, and just
typing those four letters is enough to condemn you to Silicon Hell.  We
disagree - this particular use of goto is an elegant solution to a particularly
nasty problem. It removes the need to need to duplicate the cleanup code or get
into a confusing case of nesting.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">This style gets more compact with the
use of the BailOSErr macro, first seen by us in QuickTime sample code.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">#define BailOSErr(a) {result = (a) ; if (result != noErr) goto
bail;}<a href="https://googledrive.com/host/0B7cAS_dEul22MlEtRFhabkc0a2c/personality.html#_ftn2" name="_ftnref2" title=""><span class="MsoFootnoteReference">[2]</span></a></p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">By using the BailOSErr macro a block
like this:</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">result = NewGWorld(&amp;inWorld, 8, &amp;inRect, grayTab, NULL,
0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
if (result != noErr)<br>
&nbsp;&nbsp;&nbsp;&nbsp; goto bail;</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">or this:</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">if (result = NewGWorld(&amp;inWorld, 8, &amp;inRect, grayTab,
NULL, 0))<br>
&nbsp;&nbsp;&nbsp;&nbsp; goto bail;</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">turns into this line :</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">BailOSErr( NewGWorld(&amp;inWorld, 8, &amp;inRect, grayTab, NULL,
0) );</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">It is also helpful to write dispose
functions for commonly disposed toolbox objects like the two below. These
ignore NULL values, and write NULL back to the disposed variable, preventing a
double dispose.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code"><br>
void DisposeIfGWorld(GWorldPtr&nbsp;&nbsp;&nbsp;&nbsp; *gw)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; if ( (gw != NULL) &amp;&amp; (*gw != NULL))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisposeGWorld(*gw);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *gw = NULL;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
}<br>
<br>
void DisposeIfCTable(CTabHandle&nbsp;&nbsp;&nbsp; *ct)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; if ( (ct != NULL) &amp;&amp; (*ct != NULL))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisposeCTable(*ct);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ct = NULL;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
}<br>
<br>
</p>

<p class="FigureLabel" align="left" style="text-align:left">Listing 8. Wrapper
functions for disposing Toolbox objects.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">Here is a version using the new
stuff:</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code"><br>
OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResizeGrayScalePicHandle(&nbsp;&nbsp;&nbsp;&nbsp; PicHandle&nbsp;&nbsp; inPic,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PicHandle
&nbsp; *outPic,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
&nbsp;&nbsp;&nbsp;&nbsp; scale)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; Rect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inRect
= inPic[0]-&gt;picFrame, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outRect
= inRect;<br>
&nbsp;&nbsp;&nbsp;&nbsp; GWorldPtr&nbsp;&nbsp; inWorld = NULL, outWorld = NULL;<br>
&nbsp;&nbsp;&nbsp;&nbsp; GDHandle&nbsp;&nbsp;&nbsp; saveGD;<br>
&nbsp;&nbsp;&nbsp;&nbsp; CGrafPtr&nbsp;&nbsp;&nbsp; savePort;<br>
&nbsp;&nbsp;&nbsp;&nbsp; CTabHandle&nbsp; grayTab =
GetCTable(k8BitGrayScaleID);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; GetGWorld(&amp;savePort, &amp;saveGD);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (grayTab == NULL)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BailOSErr(memFullErr);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; ZeroRect(&amp;inRect);<br>
&nbsp;&nbsp;&nbsp;&nbsp; ScaleRect(&amp;outRect, scale);<br>
&nbsp;&nbsp;&nbsp;&nbsp; BailOSErr( NewGWorld(&amp;inWorld, 8, &amp;inRect,
grayTab, NULL, 0));<br>
&nbsp;&nbsp;&nbsp;&nbsp; BailOSErr( NewGWorld(&amp;outWorld, 8, &amp;outRect,
grayTab, NULL, 0));<br>
&nbsp;&nbsp;&nbsp;&nbsp; SetGWorld(inWorld, NULL);<br>
&nbsp;&nbsp;&nbsp;&nbsp; LockPixels(GetGWorldPixMap(inWorld));<br>
&nbsp;&nbsp;&nbsp;&nbsp; LockPixels(GetGWorldPixMap(outWorld));<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; EraseRect(&amp;inRect);<br>
&nbsp;&nbsp;&nbsp;&nbsp; DrawPicture(inPic, &amp;inRect);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; SetGWorld(outWorld, NULL);<br>
&nbsp;&nbsp;&nbsp;&nbsp; CopyBits(&nbsp;&nbsp; (BitMap*)
*inWorld-&gt;portPixMap,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (BitMap*)
*outWorld-&gt;portPixMap,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;inRect,
&amp;outRect, ditherCopy, NULL );<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; DisposeIfGWorld(&amp;inWorld);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; *outPic = OpenPicture(&amp;outRect);<br>
&nbsp;&nbsp;&nbsp;&nbsp; CopyBits(&nbsp;&nbsp; &amp;qd.thePort-&gt;portBits,
&amp;qd.thePort-&gt;portBits,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;outRect,
&amp;outRect,srcCopy, NULL);<br>
&nbsp;&nbsp;&nbsp;&nbsp; ClosePicture();<br>
<br>
bail:<br>
&nbsp;&nbsp;&nbsp;&nbsp; DisposeIfGWorld(&amp;inWorld);<br>
&nbsp;&nbsp;&nbsp;&nbsp; DisposeIfGWorld(&amp;outWorld);<br>
&nbsp;&nbsp;&nbsp;&nbsp; DisposeIfCTable(&amp;grayTab);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; SetGWorld(savePort, saveGD);<br>
&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
}</p>

<p class="Bodytext">&nbsp;</p>

<p class="FigureLabel">Listing 9. Macros &amp; dispose wrappers, make Realism
compact.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">The step beyond Realism is to add a
dose of Cynicism. We like to tag all our data structures, so we can recognise
them when they are passed in again. The overhead is low, and it makes your
modules almost bullet-proof.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">We write in a component orientated
style, based on the way the Mac Toolbox behaves. Programs we've written, like "3D
Atlas", use all sorts of objects. For instance we've written our own picture
buttons, which draw in various sophisticated ways. To create one of these you
call NewButton which gives you a ButtonHandle. To draw it you pass that
ButtonHandle to DrawButton, to dispose it you call DisposeButton, etc. </p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">Structures like ButtonHandles have a
tag at the front. This is an OSType - in the case of a ButtonHandle it is
initialised to the value ‘Bttn' when a ButtonHandle is created.  </p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">// some fields removed for clarity<br>
<br>
typedef struct<br>
&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp; OSType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tag;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
here is the tag<br>
&nbsp;&nbsp;&nbsp;&nbsp; Rect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buttonRect;<br>
&nbsp;&nbsp;&nbsp;&nbsp; short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; baseID; &nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; }ButtonRec, *ButtonPtr, **ButtonHandle;</p>

<p class="Bodytext">&nbsp;</p>

<p class="FigureLabel">Listing 10. Tag it, so you'll recognise it again.</p>

<p class="Bodytext">&nbsp;</p>

<h2>Cynical</h2>

<p class="Bodytext" style="text-indent:0in">These tags are fabulously useful
things, if like us you have gone beyond being Realists and have become really
quite Cynical. All externally visible functions in Button.c verify the
ButtonHandle argument they were passed is not NULL, is not a purged handle, and
that it has the correct tag. This is done with a macro called "Check" that is
defined at the top of Buttons.c.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code"><br>
static OSType kTag  = 'Bttn';<br>
static char kTypeName[] = "ButtonHandle";<br>
<br>
#define Check(b) CheckObject((Handle)b, kTag, kTypeName)<br>
<br>
<br>
CheckObject is a function that is used throughout the program:<br>
<br>
<br>
OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CheckObject(Handle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h,
OSType&nbsp;&nbsp; tag, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expectedType)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result =
noErr;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (h == nil)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result =
nilHandleErr;<br>
&nbsp;&nbsp;&nbsp;&nbsp; else if (*h == nil)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result =
nilHandleErr;<br>
&nbsp;&nbsp;&nbsp;&nbsp; else if (*(long*)*h != tag)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = paramErr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
#ifdef DEBUG<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (result)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp; str[256];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(&nbsp;&nbsp;&nbsp; str,
 "CheckObject failure type %hd on %s", <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result,
expectedType);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DebugText(str);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
#endif<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
}</p>

<p class="FigureLabel">Listing 11. CheckObject</p>

<p class="Bodytext" style="text-indent:0in">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">Here's a simple example which uses
the Check macro.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ShowButton(ButtonHandle button)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result  =
Check(button);<br>
&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; if (result == noErr)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; button [0]-&gt;
visible = true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result =
DrawButton(button);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
}</p>

<p class="Bodytext">&nbsp;</p>

<p class="FigureLabel">Listing 12. It's easy to check that Handles are the right
type.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">If you call ShowButton and instead of
passing it a ButtonHandle you pass it NULL, a purged Handle, or a PicHandle
containing a picture of your grandmother, that error will be detected
immediately. We've found that this is mainly useful for catching coding errors
while still in the development phase, and that the most common error is to try
and act on a NULL object.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">The tag also enables you to recognise
ButtonHandles when browsing through the heap with a tool like ZoneRanger.</p>

<p class="Bodytext" style="text-indent:0in">Lastly, the DisposeButton routine
sets the tag to 0, so it is not possible to dispose a valid ButtonHandle twice.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">void DisposeButton(ButtonHandle theButton)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (Check(theButton) == noErr)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; theButton [0]-&gt;
tag = 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // dispose any
storage owned by the object here<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisposeHandle((Handle)theButton);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
}<br>
<br>
</p>

<p class="FigureLabel">Listing 13. Clear the tag before you dispose.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">For the cost of some little 4-byte
tag, your program's internal routines can gain a lot more ruggedness.</p>

<p class="Bodytext">&nbsp;</p>

<h2>Those Damn Optimists Again</h2>

<p class="Bodytext" style="text-indent:0in">The Mac Resource Manager is a bit of
a mine-field for the Optimist. </p>

<p class="Bodytext" style="text-indent:0in">For instance, what's wrong with this
code that uses purgeable ‘PICT' resources?</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawTwoPictures(short&nbsp;&nbsp; id1,
short id2)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; Rect&nbsp; r = {0,0,100,100};<br>
&nbsp;&nbsp;&nbsp;&nbsp; Handle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pic1 =
GetResource('PICT', id1);<br>
&nbsp;&nbsp;&nbsp;&nbsp; Handle  pic2 = GetResource('PICT', id2);<br>
&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; DrawPicture(&amp;r, (PicHandle)pic1);<br>
&nbsp;&nbsp;&nbsp;&nbsp; DrawPicture(&amp;r, (PicHandle)pic2);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; return noErr;<br>
}</p>

<p class="FigureLabel">Listing 14. Might work, might not,</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">The previous function assumes a lot
of things. It assumes that the resources both exist, can fit in memory
together, have not been purged already, and don't get purged in the course of
the function. When one of those assumptions fails, you will be in trouble.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">Purgeable resources are a very
powerful tool, giving your app a free caching scheme, but a lot of people
forget that GetResource can give you back a purged Handle, or that loading one
resource can push out another.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">To challenge some of these
assumptions it helps to have a function like this to call. If CheckResource
says the resource Handle is OK, and you then make it non-purgeable, you can
count on using it in your code.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">// verify a resource handle, reloading it if needed<br>
OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CheckResource(Handle&nbsp;&nbsp;&nbsp; h)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (h == NULL)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
resNotFound;<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (*h == NULL)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadResource(h);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*h == NULL)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
memFullErr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp; return noErr;<br>
}<br>
<br>
</p>

<p class="FigureLabel">Listing 15. CheckResource is your friend.</p>

<h2>Realism In Action</h2>

<p class="Bodytext" style="text-indent:0in">Given the CheckResource function, it
is possible to write a more Realist version of this function with blocks like
this:</p>

<p class="Bodytext" style="text-indent:0in">&nbsp;</p>

<p class="Code">pic1 = GetResource('PICT', id1);<br>
if (result = CheckResource(pic1))<br>
&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp; pic1 = NULL;<br>
&nbsp;&nbsp;&nbsp;&nbsp; goto bail;<br>
&nbsp;&nbsp;&nbsp;&nbsp; }<br>
pic1State = GetHState(pic1);<br>
HNoPurge(pic1);<br>
<br>
</p>

<p class="FigureLabel">Listing 16. Real programmers save and restore state.</p>

<p class="Code">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">You restore the Handle's (probably
purgeable) state at the end with HSetState.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">This code can be made a lot less
cumbersome the use of a simple function called SafeGetResource. This function
gets the valid resource data, saving the Handle's state (locked, purgeable,
etc), and makes it non-purgeable. To clean up at the end, just use HSetState to
return the Handle to its initial state (ie purgeable). </p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SafeGetResource(&nbsp; Handle
*retHandle, char *retState, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResType
theType,  short theID)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; Handle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h =
GetResource(theType, theID);<br>
&nbsp;&nbsp;&nbsp;&nbsp; OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result =
noErr;<br>
&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; if (result = CheckResource(h))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *retHandle = 0;</p>

<p class="Code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
only complain on the debug build<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DebugText("SafeGetResource
failed"); <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *retState =
HGetState(h);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *retHandle = h;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HNoPurge(h);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
}</p>

<p class="Bodytext">&nbsp;</p>

<p class="FigureLabel">Listing 17. Making your resource code bullet-proof.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">Why is it important to make a
purgeable resource non-purgeable as soon as you've made sure it is loaded?</p>

<p class="Bodytext" style="text-indent:0in">Because it is not possible to count
on a purgeable resource after you have made any calls that could have caused
the heap to be purged, and that means any calls that allocate memory, directly
or indirectly.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">This following code is bogus, for
instance, because the second resource can push the first out of memory when it
loads. You can only count on resources in non-purgeable Handles.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">h1 = GetResource('PICT', 1);<br>
BailOSErr( CheckResource(h1) );<br>
<br>
h2 = GetResource('PICT', 2);<br>
BailOSErr( CheckResource(h2) );</p>

<p class="CodeComment">// by this point we have the second PICT, but that PICT
could have</p>

<p class="CodeComment">// pushed the first out of memory</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">Now we have enough tools to write a
version of the function that cannot be made to misbehave by missing resources,
limited memory or purged Handles. Note that we do not use ReleaseResource in
this case since we know these resources were originally marked purgeable, so
we'll get the memory eventually if we need it. </p>

<p class="Code"><br>
OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawTwoPictures(short&nbsp;&nbsp; id1,
short id2)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; Handle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pic1 = NULL;<br>
&nbsp;&nbsp;&nbsp;&nbsp; Handle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pic2 = NULL;<br>
&nbsp;&nbsp;&nbsp;&nbsp; Rect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r =
{0,0,100,100};<br>
&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pic1State,
pic2State;<br>
&nbsp;&nbsp;&nbsp;&nbsp; OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result =
noErr;<br>
&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; BailOSErr( SafeGetResource( &amp;pic1, &amp;pic1State,
'PICT', id1) );<br>
&nbsp;&nbsp;&nbsp;&nbsp; BailOSErr( SafeGetResource( &amp;pic2, &amp;pic2State,
'PICT', id2) );<br>
&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; DrawPicture(&amp;r, pic1);<br>
&nbsp;&nbsp;&nbsp;&nbsp; DrawPicture(&amp;r, pic2);<br>
<br>
bail:<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (pic1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HSetState(pic1,
pic1State);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (pic2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HSetState(pic2,
pic2State);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; return result;<br>
}</p>

<p class="Bodytext">&nbsp;</p>

<p class="FigureLabel">Listing 18. With SafeGetResource, your purgeable resource
code is robust.</p>

<p class="FigureDescription">&nbsp;</p>

<h2>Myopic</h2>

<p class="Bodytext" style="text-indent:0in">Some programmers don't see what their
code does very clearly, so we call them "myopic" (short-sighted). We had a job
applicant once who proudly showed us his code, including his own version of
strcpy. He claimed the version in the standard library didn't work (which
seemed unlikely). We were immediately suspicious,  so we checked out his
version.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">void strcpy(char *out, char *in)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; x;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; for (x = 0 ; x &lt;= strlen(in)  ; x++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out[x] = in[x];<br>
}</p>

<p class="FigureLabel">Listing 19. Slow version of strcpy.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">We don't think the programmer meant
to measure the length of the source string again, every single time around the
loop. Of course, fixing that bug would not be enough in itself, since the
routine has other faults too.<a href="https://googledrive.com/host/0B7cAS_dEul22MlEtRFhabkc0a2c/personality.html#_ftn3" name="_ftnref3" title=""><span class="MsoFootnoteReference">[3]</span></a></p>

<p class="Code">&nbsp;</p>

<p class="FigureLabel">&nbsp;</p>

<h2>Obfuscators</h2>

<p class="Bodytext" style="text-indent:0in">A related character flaw is the
person who optimises the amount of on-screen space the code takes up, instead
of the compiled output. We would call these Obfuscators.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">This routine is supposed to make all
the characters in a string lower case.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">void LowText(char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *a)</p>

<p class="Code">{</p>

<p class="Code">&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp; *b=a;</p>

<p class="Code">&nbsp;&nbsp;&nbsp;&nbsp; while(*a) *b++ = (islower(*a))?
*a++:*a++ + ('a'-'A');</p>

<p class="Code">&nbsp;&nbsp;&nbsp;&nbsp; *b = 0;</p>

<p class="Code">}</p>

<p class="FigureLabel"><span style="font-size:10.0pt;font-family:Courier;
font-weight:normal;font-style:normal">&nbsp;</span></p>

<p class="FigureLabel">Listing 20. Obfuscator at work.</p>

<p class="Bodytext"><br>
We're not sure why writing code like this is popular, but it certainly isn't
clear. Let's reformat it to be less secretive and obfuscated:</p>

<p class="MsoNormal"><span style="font-family:Geneva">&nbsp;</span></p>

<p class="Code">static const char kLowerCaseOffset = 'a'-'A';</p>

<p class="Code">&nbsp;</p>

<p class="Code">void LowText(char* inStr)</p>

<p class="Code">{</p>

<p class="Code">&nbsp;&nbsp;&nbsp;&nbsp; char* outStr = inStr;<br>
<br>
</p>

<p class="Code">&nbsp;&nbsp;&nbsp;&nbsp; while(*inStr != 0)</p>

<p class="Code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>

<p class="Code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(islower(*inStr))</p>

<p class="Code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *outStr++
= *inStr++;</p>

<p class="Code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</p>

<p class="Code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *outStr++
= *inStr++ + kLowerCaseOffset;</p>

<p class="Code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p class="Code"><br>
&nbsp;&nbsp;&nbsp;&nbsp; *outStr = 0;</p>

<p class="Code">}</p>

<p class="Code"><span style="font-family:Geneva">&nbsp;</span></p>

<p class="FigureLabel">Listing 21. Less Obfuscated, so it's easier to see the
bug.</p>

<p class="MsoNormal"><span style="font-family:Geneva">&nbsp;</span></p>

<p class="Bodytext" style="text-indent:0in">Now we can see what it's doing, it is
a lot more obvious that it will not cope with any input text that isn't letters
- for example it will turn '0' to '9' into 'P' to 'Y'.</p>

<p class="Bodytext" style="text-indent:0in">It's also Prejudiced - it assumes the
text is in English, and the ASCII character set, so the Japanese version isn't
going to work very well. It also scorns the rather nice Toolbox routines that
deal with text, which could be called Arrogant. To be Tolerant, you could
rewrite it like this:</p>

<p class="MsoNormal"><span style="font-family:Geneva">&nbsp;</span></p>

<p class="Code">OSErr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LowText(char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *inStr)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; if (inStr == nil)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DebugText("nil
string passed to LowText");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return paramErr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; LowercaseText(inStr, strlen(inStr), smSystemScript);<br>
&nbsp;&nbsp;&nbsp;&nbsp; return noErr;<br>
}</p>

<p class="Code">&nbsp;</p>

<p class="FigureLabel">Listing 22. In this case it's best to let the OS do it
anyway.</p>

<p class="Code">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">Another way of being Secretive and
Obfuscatory is to use C++ overloading in conjunction with inheritance between
lots of classes so that the only way of telling which function is being called
is with a source-level debugger. We'd give example code here, but it would take
about six source files to demonstrate properly...</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext">&nbsp;</p>

<h2>Paranoid</h2>

<p class="Bodytext" style="text-indent:0in">Paranoid programmers worry about
things that can't possibly go wrong. They end up creating lots of extra work
for themselves, because they are always looking in the wrong place for trouble.
</p>

<p class="Bodytext" style="text-indent:0in">Take a simple function like this:</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">Boolean&nbsp;&nbsp;&nbsp; RectIsOnMainScreen(Rect r)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; Rect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resultRect;<br>
&nbsp;&nbsp;&nbsp;&nbsp; GDHandle&nbsp;&nbsp;&nbsp; gd = GetMainDevice();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; return SectRect(&amp;r, &amp;gd [0]-&gt; gdRect,
&amp;resultRect);<br>
}<br>
<br>
</p>

<p class="FigureLabel">Listing 23. Simple function.</p>

<p class="Code">&nbsp;</p>

<p class="Code">&nbsp;</p>

<p class="Code"><span style="font-size:12.0pt;font-family:Times">A Paranoid
programmer would write it like this:<br>
</span><br>
<br>
Boolean&nbsp;&nbsp;&nbsp; RectIsOnMainScreen(Rect r)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; Rect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resultRect;<br>
&nbsp;&nbsp;&nbsp;&nbsp; GDHandle&nbsp;&nbsp;&nbsp; gd = GetMainDevice();<br>
&nbsp;&nbsp;&nbsp;&nbsp; Boolean&nbsp;&nbsp;&nbsp;&nbsp; doesIntersect;<br>
&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hState;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; hState = HGetState( (Handle) gd );<br>
&nbsp;&nbsp;&nbsp;&nbsp; HLock((Handle)gd);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
totally time consuming and bogus<br>
&nbsp;&nbsp;&nbsp;&nbsp; doesIntersect = SectRect(&amp;r, &amp;gd [0]-&gt;
gdRect, &amp;resultRect);<br>
&nbsp;&nbsp;&nbsp;&nbsp; HSetState((Handle)gd, hState);<br>
&nbsp;&nbsp;&nbsp;&nbsp; return doesIntersect;<br>
}</p>

<p class="FigureLabel">Listing 24. Paranoid version.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">All the above code that messes around
with the locked state of the Handle is completely un-needed. SectRect does not
move memory. We have even seen a more pathological variant of this – where a
programmer calls HLockHi for no good reason, causing heap compactions all over
the place. Even if SectRect was a function that moved memory, using a temporary
Rect variable would be a better solution.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">But the consequences of Paranoia can
be much darker, especially when combined with Prejudice. The Mercutio bug that
caused panic some months ago was caused by some code similar to this:</p>

<p class="Bodytext">&nbsp;</p>

<p class="Code">Boolean&nbsp;&nbsp;&nbsp; RectIsOnMainScreen(Rect r)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; Rect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resultRect;<br>
&nbsp;&nbsp;&nbsp;&nbsp; GDHandle&nbsp;&nbsp;&nbsp; gd = GetMainDevice();<br>
&nbsp;&nbsp;&nbsp;&nbsp; Boolean&nbsp;&nbsp;&nbsp;&nbsp; doesIntersect;<br>
&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; HLock((Handle)gd);<br>
&nbsp;&nbsp;&nbsp;&nbsp; doesIntersect = SectRect(&amp;r, &amp;gd [0]-&gt;
gdRect, &amp;resultRect);<br>
&nbsp;&nbsp;&nbsp;&nbsp; HUnlock((Handle)gd);<br>
&nbsp;&nbsp;&nbsp;&nbsp; return doesIntersect;<br>
} </p>

<p class="Bodytext">&nbsp;</p>

<p class="FigureLabel">Listing 25. Paranoia + Prejudice = Trouble.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">The above code doesn't bother to save
and restore the state of the GDHandle, and always leaves it unlocked. Since
GDHandles should ALWAYS be locked (unless pain is something that you enjoy),
this is a Bad Thing. </p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">Writing a version of SectRect that
does move memory is left as an exercise for the reader.</p>

<span style="font-size:18.0pt;font-family:Times"><b><br clear="ALL" style="page-break-before:always">
</b></span>

<h1>Conclusion </h1>

<h2>We're optimistic about cynicism.</h2>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">Cynicism works well as a programming
personality because it leads you to expect the worst, so you are forced to
write code that can cope with that situation.</p>

<p class="Bodytext" style="text-indent:0in">And the truth is that failure is far
more likely than a lot of programmers seem to think, given that it can be
caused by actions including :</p>

<p class="list" style="margin-left:14.2pt;text-indent:0in;tab-stops:14.2pt 38.15pt">
</p><ul compact="" type="disc">
	<li>Allocating even one byte of storage,<br></li>
	<li>Reading from the disc.<br></li>
	<li> Writing to the disc.<br></li>
	<li> Using a purgeable block of memory.<br></li>
	<li> Using a parameter that may be invalid.<br></li>
	<li> Calling another function that does one of the above.</li>
</ul>
<p></p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">It has been pointed out before that
one good thing about being a Cynic, is that you are so rarely disappointed.</p>

<p class="Bodytext">&nbsp;</p>

<p class="Bodytext">&nbsp;</p>

<h1>Bibliography</h1>

<p class="Bodytext" style="text-indent:0in">Further reading: TN 1118, TN 1120,  </p>

<p class="Bodytext" style="text-indent:0in">"Code Complete" by Steve McConnell,
Microsoft Press, </p>

<p class="Bodytext" style="text-indent:0in">"Writing Solid Code" by Steve
Maguire, Microsoft Press</p>

<p class="Bodytext" style="text-indent:0in">&nbsp;</p>

<h1>About the authors</h1>

<p class="Bodytext" style="text-indent:0in">Kevin Marks works for Apple Computer
in the QuickTime Group.</p>

<p class="Bodytext" style="text-indent:0in">Maf Vosburgh works for Microsoft in the Mac Business Unit.</p>

<p class="Bodytext" style="text-indent:0in">&nbsp;</p>

<p class="Bodytext" style="text-indent:0in">By an amazing coincidence, both are
British, both like sushi, and both used to work at the same company in London,
where they both wrote "3D Atlas" (well, half each).</p>

</div>

<div><br clear="all">

<hr align="left" size="1" width="33%">

<div id="ftn1">

<p class="MsoFootnoteText"><a href="https://googledrive.com/host/0B7cAS_dEul22MlEtRFhabkc0a2c/personality.html#_ftnref1" name="_ftn1" title=""><span class="MsoFootnoteReference">[1]</span></a> The sequence [0]-&gt; is called
"sprong", and is a convenient way to use a typed Handle to a struct. We could
have used  <span style="font-size:9.0pt;font-family:Courier">"inRect =
(**inPic).picFrame" </span>with the same result. </p>

<p class="MsoFootnoteText">Sprong is particularly useful when dealing with chains
of typed Handles to structs, as in this example:</p>

<p class="MsoFootnoteText">&nbsp;</p>

<p class="MsoFootnoteText"><span style="font-size:9.0pt;font-family:Courier">short&nbsp; depth
= GetMainDevice() [0]-&gt; gdPMap [0]-&gt; pixelSize;</span></p>

</div>

<div id="ftn2">

<p class="MsoFootnoteText"><a href="https://googledrive.com/host/0B7cAS_dEul22MlEtRFhabkc0a2c/personality.html#_ftnref2" name="_ftn2" title=""><span class="MsoFootnoteReference">[2]</span></a> Actually, this macro would be better
written wrapped with "do/while", like this</p>

<p class="MsoFootnoteText"><span style="font-size:9.0pt;font-family:Courier">#define
BailOSErr(a) do {result = (a) ; if (result != noErr) goto bail;} while(0)</span></p>

<p class="MsoFootnoteText">because then you can write "<span style="font-size:
9.0pt;font-family:Courier">if (x) BailOSErr(foo()); else BailOSErr(bar());"</span>
without getting an error message from the C compiler.</p>

<p class="MsoFootnoteText">&nbsp;</p>

</div>

<div id="ftn3">

<p class="MsoFootnoteText"><a href="https://googledrive.com/host/0B7cAS_dEul22MlEtRFhabkc0a2c/personality.html#_ftnref3" name="_ftn3" title=""><span class="MsoFootnoteReference">[3]</span></a> Other faults - it returns void
instead of a pointer to the destination string, only copies strings up to a
certain length, and is not very fast. A valid strcpy can be written very
compactly in C though, if you try.</p>

</div>

</div>




<iframe frameborder="0" scrolling="no" style="background-color: transparent; border: 0px; display: none;"></iframe><div id="GOOGLE_INPUT_CHEXT_FLAG" style="display: none;" input="null" input_stat="{&quot;tlang&quot;:null,&quot;tsbc&quot;:null,&quot;pun&quot;:null,&quot;mk&quot;:false,&quot;ss&quot;:true}"></div></body></html>